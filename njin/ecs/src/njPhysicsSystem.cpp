#include "ecs/njPhysicsSystem.h"

#include <chrono>
#include <ranges>

#include "ecs/Components.h"
#include "physics/BVH.h"
constexpr std::intmax_t TICK_RATE{ 60 };
constexpr float DT{ 1.0 / TICK_RATE };

namespace njin::ecs {

    namespace {
        /**
         * Incorporate movement intents generated by inputs into the dynamics
         * state for this tick
         * @param entity_manager Entity manager
         */
        void resolve_inputs(const ecs::njEntityManager& entity_manager) {
            const auto views{
                entity_manager
                .get_views<njMovementIntentComponent, njPhysicsComponent>()
            };
            for (const auto& view : views | std::views::values) {
                const auto physics{ std::get<njPhysicsComponent*>(view) };
                const auto intent{ std::get<njMovementIntentComponent*>(view) };

                if (intent->velocity_override) {
                    physics->velocity = intent->velocity;
                } else {
                    physics->velocity = physics->velocity + intent->velocity;
                }
            }
        }

        /**
         * Find the axis-aligned penetration vector that separates two AABBs.
         * @param first First AABB
         * @param second Second AABB
         * @return Penetration vector. This is the direction the first bounding
         * box must move in to separate from the second bounding box
         * @note This assumes the two AABBs overlap at least along one axis
         */
        math::njVec3f
        find_penetration_vector(const physics::BoundingBox& first,
                                const physics::BoundingBox& second) {
            // each overlap value is signed because it is the vector that first
            // needs to move to separate from second along that axis

            // we know that either first has to move along the positive
            // direction of the given axis, or the negative direction, to
            // separate from second
            // therefore we can just take the minimum of the two
            // to find the minimum depenetration vector along a given axis
            using namespace std;
            float x_minus{ second.min_x - first.max_x };
            float x_plus{ second.max_x - first.min_x };
            float x_overlap{ 0.f };
            if (abs(x_minus) < abs(x_plus)) {
                x_overlap = x_minus;
            } else {
                x_overlap = x_plus;
            }

            float y_minus{ second.min_y - first.max_y };
            float y_plus{ second.max_y - first.min_y };
            float y_overlap{ 0.f };
            if (abs(y_minus) < abs(y_plus)) {
                y_overlap = y_minus;
            } else {
                y_overlap = y_plus;
            }

            float z_minus{ second.min_z - first.max_z };
            float z_plus{ second.max_z - first.min_z };
            float z_overlap{ 0.f };
            if (abs(z_minus) < abs(z_plus)) {
                z_overlap = z_minus;
            } else {
                z_overlap = z_plus;
            }

            // when we depenetrate we move objects apart by an extra 2 * machine epsilon
            // to avoid the situation where the objects were moved apart
            // by their original depenetrating vector but still count as
            // "overlapping" due to floating point imprecisions

            // we can't use 1 * machine epsilon because if objects are moved
            // away from each other by moving each object half the length of the
            // depenetrating vector it would imply the extra offset is halved,
            // and we can't have half of a machine epsilon by definition

            // you can just remove the "* 2" portion below to see what happens
            // -- objects are not moved apart enough and still count as overlapping
            // and the program gets stuck in an infinite loop

            float epsilon{ std::numeric_limits<float>::epsilon() * 2 };
            // x is the smallest
            if (abs(x_overlap) < abs(y_overlap) &&
                abs(x_overlap) < abs(z_overlap)) {
                if (x_overlap < 0) {
                    return { x_overlap - epsilon, 0.f, 0.f };
                } else {
                    return { x_overlap + epsilon, 0.f, 0.f };
                }
            } else if (abs(y_overlap) < abs(x_overlap) &&
                       abs(y_overlap) < abs(z_overlap)) {
                // y is the smallest
                if (y_overlap < 0) {
                    return { 0.f, y_overlap - epsilon, 0.f };
                } else {
                    return { 0.f, y_overlap + epsilon, 0.f };
                }
            } else {
                // z is the smallest
                if (z_overlap < 0) {
                    return { 0.f, 0.f, z_overlap - epsilon };
                } else {
                    return { 0.f, 0.f, z_overlap + epsilon };
                }
            }
        }
    }  // namespace

    njPhysicsSystem::njPhysicsSystem() : njSystem{ TickGroup::Two } {}

    void njPhysicsSystem::update(const ecs::njEntityManager& entity_manager) {
        if (!should_update()) {
            return;
        }

        // write information the render system needs this loop
        resolve_inputs(entity_manager);

        write_current_transforms(entity_manager);

        // do initial verlet
        calculate_new_transforms(entity_manager);

        // tentative primitives
        std::vector<physics::Primitive> tentative_primitives{
            calculate_primitives(entity_manager)
        };

        physics::BVH bvh{ depenetrate(entity_manager, tentative_primitives) };

        // answer shape casts
    }

    bool njPhysicsSystem::should_update() {
        using namespace std::chrono;

        duration<steady_clock::rep, std::ratio<1, TICK_RATE>> interval{ 1 };

        TimePoint now{ Clock::now() };
        Duration elapsed{ now - previous_ };
        if (elapsed > interval) {
            previous_ = now;
            return true;
        }
        return false;
    }

    void njPhysicsSystem::write_current_transforms(const ecs::njEntityManager&
                                                   entity_manager) {
        // we only want to change the transforms of entities managed by the
        // physics system i.e. those with an njPhysicsComponent
        const auto views{
            entity_manager.get_views<njTransformComponent, njPhysicsComponent>()
        };
        for (const auto& [entity, view] : views) {
            const auto transform_comp{ std::get<njTransformComponent*>(view) };
            // if this entity is new to the physics system
            // then its transform at t_i is just its starting transform
            if (!entity_to_transform_.contains(entity)) {
                entity_to_transform_[entity] = transform_comp->transform;
                continue;
            }
            const math::njMat4f transform{ entity_to_transform_.at(entity) };

            transform_comp->transform = transform;
        }
    }

    void njPhysicsSystem::calculate_new_transforms(const ecs::njEntityManager&
                                                   entity_manager) {
        auto views{
            entity_manager.get_views<njTransformComponent, njPhysicsComponent>()
        };

        for (const auto& [entity, view] : views) {
            auto transform_comp{ std::get<njTransformComponent*>(view) };
            auto physics_comp{ std::get<njPhysicsComponent*>(view) };

            // force components
            float f_x{ physics_comp->force.x };
            float f_y{ physics_comp->force.y };
            float f_z{ physics_comp->force.z };

            // acceleration components
            float m{ physics_comp->mass };
            float a_x{ f_x / m };
            float a_y{ f_y / m };
            float a_z{ f_z / m };

            // velocity components
            float v_x{ physics_comp->velocity.x };
            float v_y{ physics_comp->velocity.y };
            float v_z{ physics_comp->velocity.z };

            // position at t_i
            math::njMat4f global_transform{ transform_comp->transform };
            math::njVec4f translation_part{ global_transform.col(3) };
            math::njVec3f t{ translation_part.x,
                             translation_part.y,
                             translation_part.z };

            // transform at t_(i+1)
            float new_x{ t.x + v_x * DT + 0.5f * a_x * DT * DT };
            float new_y{ t.y + v_y * DT + 0.5f * a_y * DT * DT };
            float new_z{ t.z + v_z * DT + 0.5f * a_z * DT * DT };
            math::njMat4f new_transform{ math::njMat4Type::Translation,
                                         { new_x, new_y, new_z } };

            entity_to_transform_[entity] = new_transform;

            // dynamics state at t_(i+1)
            float new_v_x{ v_x + a_x * DT };
            float new_v_y{ v_y + a_y * DT };
            float new_v_z{ v_z + a_z * DT };

            // force and mass remain unchanged
            physics_comp->velocity = { new_v_x, new_v_y, new_v_z };
        }
    }

    std::vector<physics::Primitive>
    njPhysicsSystem::calculate_primitives(const njEntityManager& entity_manager)
    const {
        std::vector<physics::Primitive> primitives{};
        auto views{ entity_manager.get_views<njPhysicsComponent>() };
        for (const auto& [entity, view] : views) {
            auto physics{ std::get<njPhysicsComponent*>(view) };

            auto& c{ physics->collider };
            math::njMat4f global_transform{ entity_to_transform_.at(entity) *
                                            c.transform };
            math::njVec3f g{
                global_transform.get_translation_part()
            };  // global coordinates
            // We can find the min/max bounding box
            // in global coordinates by finding the x/y/z extents in
            // each direction (taking into consideration the global transform),
            // then applying them as offsets to the coordinate of the
            // centroid in global space.

            // We can find the x/y/z extents by in essence transforming
            // the x/y/z min/maxs themselves, instead of particular
            // coordinates

            // The original min/max bounding box in local space
            math::njVec3f old_mins{ -c.x_width / 2,
                                    -c.y_width / 2,
                                    -c.z_width / 2 };
            math::njVec3f old_maxs{ c.x_width / 2,
                                    c.y_width / 2,
                                    c.z_width / 2 };
            // begin by setting the new mins and maxs to the centroid in global space
            // (zero volume bounding box as starting point)
            math::njVec3f new_mins{ g.x, g.y, g.z };  // new bounding box mins
            math::njVec3f new_maxs{ g.x, g.y, g.z };  // new bounding box maxs

            // current t/r/s we are working with
            using RotationScale = std::array<math::njVec3f, 3>;
            RotationScale rotation_scale{
                global_transform.get_rotation_scale_part()
            };

            // transform the original bounding box in local space to
            // find the new extents, then apply the extents to the
            // new global coordinate of the centroid
            for (int j{ 0 }; j < 3; ++j) {
                for (int k{ 0 }; k < 3; ++k) {
                    float a{ rotation_scale[j][k] * old_mins[k] };
                    float b{ rotation_scale[j][k] * old_maxs[k] };
                    if (a < b) {
                        new_mins[j] += a;
                        new_maxs[j] += b;
                    } else {
                        new_mins[j] += b;
                        new_maxs[j] += a;
                    }
                }
            }

            float max_x{ new_maxs[0] };
            float max_y{ new_maxs[1] };
            float max_z{ new_maxs[2] };
            float min_x{ new_mins[0] };
            float min_y{ new_mins[1] };
            float min_z{ new_mins[2] };

            physics::BoundingBox final{ .centroid = g,
                                        .min_x = min_x,
                                        .max_x = max_x,
                                        .min_y = min_y,
                                        .max_y = max_y,
                                        .min_z = min_z,
                                        .max_z = max_z };
            primitives.emplace_back(entity, final);
        }
        return primitives;
    }

    physics::BVH
    njPhysicsSystem::depenetrate(const njEntityManager& entity_manager,
                                 const std::vector<physics::Primitive>&
                                 primitives) {
        physics::BVH current_bvh{ primitives };
        physics::OverlappingPairs current_overlapping{
            physics::get_overlapping_pairs(current_bvh)
        };
        // we do passes over all overlapping pairs over and over again
        // until there are no more overlaps
        while (current_overlapping.size() > 0) {
            // resolve all collision pairs
            for (auto [first, second] : current_overlapping) {
                auto first_view{
                    entity_manager.get_view<njPhysicsComponent>(first)
                };
                auto first_physics{
                    std::get<njPhysicsComponent*>(first_view.second)
                };
                auto second_view{
                    entity_manager.get_view<njPhysicsComponent>(second)
                };
                auto second_physics{
                    std::get<njPhysicsComponent*>(second_view.second)
                };

                physics::BoundingBox first_box{
                    current_bvh.get_bounding_box(first)
                };
                physics::BoundingBox second_box{
                    current_bvh.get_bounding_box(second)
                };
                math::njVec3f penetration_vector{
                    find_penetration_vector(first_box, second_box)
                };

                // static-static collisions -> we do nothing
                // static objects can't move, so this basically only happens
                // if two static objects are placed overlapping each other
                // from the very beginning
                if (first_physics->type == RigidBodyType::Static &&
                    second_physics->type == RigidBodyType::Static) {
                    continue;
                }

                // dynamic-static collisions -> we move the dynamic object
                // out of the static object
                else if (first_physics->type == RigidBodyType::Static &&
                         second_physics->type == RigidBodyType::Dynamic) {
                    // the second body must move away from the first,
                    // but the penetration vector was calculated for
                    // moving the first body away from the second, so
                    // we just move in the opposite direction
                    math::njMat4f depenetrating_transform{
                        math::njMat4Type::Translation,
                        -penetration_vector
                    };

                    entity_to_transform_[second] = depenetrating_transform *
                                                   entity_to_transform_[second];
                }

                else if (first_physics->type == RigidBodyType::Dynamic &&
                         second_physics->type == RigidBodyType::Static) {
                    math::njMat4f depenetrating_transform{
                        math::njMat4Type::Translation,
                        penetration_vector
                    };

                    entity_to_transform_[first] = depenetrating_transform *
                                                  entity_to_transform_[first];

                    // we assume a completely inelastic collision - when the
                    // dynamic body collides with the static body it will come
                    // to a complete stop instead of bouncing
                    // NOTE: maybe use coefficient of restitution to determine
                    // whether something "bounces" or not?
                    first_physics->velocity = math::njVec3f::zero();
                }
                // dynamic-dynamic collisions -> we move both dynamic objects
                // away from each other
                else {
                    // this isn't a very precise way of doing things,
                    // but for now we just move each body half the length
                    // of the penetration vector

                    math::njMat4f first_depen_transform{
                        math::njMat4Type::Translation,
                        penetration_vector * 0.5
                    };

                    math::njMat4f second_depen_transform{
                        math::njMat4Type::Translation,
                        -penetration_vector * 0.5
                    };

                    entity_to_transform_[first] = first_depen_transform *
                                                  entity_to_transform_[first];
                    entity_to_transform_[second] = second_depen_transform *
                                                   entity_to_transform_[second];
                }
            }
            // update the overlapping pairs
            current_bvh = physics::BVH{ calculate_primitives(entity_manager) };
            current_overlapping = physics::get_overlapping_pairs(current_bvh);
        };

        // depenetration done, write the collider bounds to the physics
        // component
        for (const auto& [entity, _] : primitives) {
            physics::BoundingBox box{ current_bvh.get_bounding_box(entity) };
            auto view{ entity_manager.get_view<njPhysicsComponent>(entity) };
            auto physics{ std::get<njPhysicsComponent*>(view.second) };

            // the centroid of the bounding box is in global space,
            // because we prefer the physics system (particularly depenetration)
            // to work in global space.
            // but for the colliders in the physics component,
            // we only care about the local transform
            physics->current_collider = {
                .transform = physics->current_collider.transform,
                .x_width = box.max_x - box.min_x,
                .y_width = box.max_y - box.min_y,
                .z_width = box.max_z - box.min_z
            };
        }

        return current_bvh;
    }
}  // namespace njin::ecs