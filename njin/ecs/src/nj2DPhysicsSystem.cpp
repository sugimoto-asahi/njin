
#include "ecs/nj2DPhysicsSystem.h"

#include "ecs/Components.h"
#include "physics/BVH.h"
#include "physics/BVHNode.h"
constexpr std::intmax_t TICK_RATE{ 60 };
constexpr float DT{ 1.0 / TICK_RATE };

namespace {
    /**
     * Incorporate movement intents generated by inputs into the dynamics
     * state for this tick
     * @param entity_manager Entity manager
     */
    void resolve_inputs(const njin::ecs::njEntityManager& entity_manager) {
        const auto views{
            entity_manager.get_views<njin::ecs::njMovementIntentComponent,
                                     njin::ecs::nj2DPhysicsComponent>()
        };
        for (const auto& [entity, view] : views) {
            const auto physics{
                std::get<njin::ecs::nj2DPhysicsComponent*>(view)
            };
            const auto intent{
                std::get<njin::ecs::njMovementIntentComponent*>(view)
            };

            if (intent->velocity_override) {
                physics->velocity = intent->velocity;
            } else {
                physics->velocity = physics->velocity + intent->velocity;
            }
        }
    }
}  // namespace

namespace njin::ecs {

    nj2DPhysicsSystem::nj2DPhysicsSystem() : njSystem{ TickGroup::Two } {}

    void nj2DPhysicsSystem::update(const ecs::njEntityManager& entity_manager) {
        if (!should_update()) {
            return;
        }
        auto views{ entity_manager
                    .get_views<nj2DPhysicsComponent, njTransformComponent>() };
        for (const auto& view : views) {
            auto physics{ std::get<nj2DPhysicsComponent*>(view.second) };
            auto transform{ std::get<njTransformComponent*>(view.second) };

            resolve_inputs(entity_manager);

            write_current_transforms(entity_manager);
            calculate_new_transforms(entity_manager);

            // tentative primitives
            std::vector<physics::Primitive> primitives{
                calculate_primitives(entity_manager)
            };
            physics::BVH bvh{ primitives, physics::BoundingBoxType::XZ };
            physics::BoundingBox box{ bvh.get_bounding_box(26) };
            physics::BoundingBox box_2{ bvh.get_bounding_box(27) };
        }
    }

    bool nj2DPhysicsSystem::should_update() {
        using namespace std::chrono;

        duration<steady_clock::rep, std::ratio<1, TICK_RATE>> interval{ 1 };

        TimePoint now{ Clock::now() };
        Duration elapsed{ now - previous_ };
        if (elapsed > interval) {
            previous_ = now;
            return true;
        }
        return false;
    }

    std::vector<physics::Primitive>
    nj2DPhysicsSystem::calculate_primitives(const njEntityManager&
                                            entity_manager) {
        std::vector<physics::Primitive> primitives{};
        const auto& views{ entity_manager.get_views<njTransformComponent,
                                                    nj2DPhysicsComponent>() };
        for (const auto& [entity, view] : views) {
            auto transform{ std::get<njTransformComponent*>(view) };
            auto physics{ std::get<nj2DPhysicsComponent*>(view) };
            nj2DCollider collider{ physics->collider };
            // world transform of collider
            math::njMat4f world_transform{ transform->transform *
                                           collider.transform };

            physics::BoundingBox box{
                physics::BoundingBox::make(world_transform
                                           .get_translation_part(),
                                           collider.x_width,
                                           0.f,
                                           collider.z_width)
            };
            physics::Primitive primitive{ entity, box };
            primitives.push_back(primitive);
        }

        return primitives;
    }

    void nj2DPhysicsSystem::write_current_transforms(const ecs::njEntityManager&
                                                     entity_manager) {
        // we only want to change the transforms of entities managed by the
        // physics system i.e. those with an nj2DPhysicsComponent
        const auto views{ entity_manager.get_views<njTransformComponent,
                                                   nj2DPhysicsComponent>() };
        for (const auto& [entity, view] : views) {
            const auto transform_comp{ std::get<njTransformComponent*>(view) };
            // if this entity is new to the physics system
            // then its transform at t_i is just its starting transform
            if (!transforms_.contains(entity)) {
                transforms_[entity] = transform_comp->transform;
                continue;
            }
            const math::njMat4f transform{ transforms_.at(entity) };

            transform_comp->transform = transform;
        }
    }

    void nj2DPhysicsSystem::calculate_new_transforms(const ecs::njEntityManager&
                                                     entity_manager) {
        auto views{ entity_manager
                    .get_views<njTransformComponent, nj2DPhysicsComponent>() };

        for (const auto& [entity, view] : views) {
            auto transform_comp{ std::get<njTransformComponent*>(view) };
            auto physics_comp{ std::get<nj2DPhysicsComponent*>(view) };

            // force components
            float f_x{ physics_comp->force.x };
            float f_y{ 0.f };
            float f_z{ physics_comp->force.z };

            // acceleration components
            float m{ physics_comp->mass };
            float a_x{ f_x / m };
            float a_y{ f_y / m };
            float a_z{ f_z / m };

            // velocity components
            float v_x{ physics_comp->velocity.x };
            float v_y{ physics_comp->velocity.y };
            float v_z{ physics_comp->velocity.z };

            // position at t_i
            math::njMat4f global_transform{ transform_comp->transform };
            math::njVec4f translation_part{ global_transform.col(3) };
            math::njVec3f t{ translation_part.x,
                             translation_part.y,
                             translation_part.z };

            // transform at t_(i+1)
            float new_x{ t.x + v_x * DT + 0.5f * a_x * DT * DT };
            float new_y{ t.y + v_y * DT + 0.5f * a_y * DT * DT };
            float new_z{ t.z + v_z * DT + 0.5f * a_z * DT * DT };
            math::njMat4f new_transform{ math::njMat4Type::Translation,
                                         { new_x, new_y, new_z } };

            transforms_[entity] = new_transform;

            // dynamics state at t_(i+1)
            float new_v_x{ v_x + a_x * DT };
            float new_v_y{ v_y + a_y * DT };
            float new_v_z{ v_z + a_z * DT };

            // force and mass remain unchanged
            physics_comp->velocity = { new_v_x, new_v_y, new_v_z };
        }
    }
}  // namespace njin::ecs